# -*- coding: utf-8 -*-

from twisted.internet import defer
import pandas as pd
import matplotlib.pyplot as plt
import logging
from collections import OrderedDict
from util import utiltools
from util.utili18n import le2mtrans
import DictatorParams as pms
from DictatorTexts import _DIC


logger = logging.getLogger("le2m.{}".format(__name__))


class Serveur(object):
    def __init__(self, le2mserv):
        self._le2mserv = le2mserv
        actions = OrderedDict()
        actions[le2mtrans(u"Settings")] = self._configure
        actions[le2mtrans(u"Display settings")] = \
            lambda _: self._le2mserv.gestionnaire_graphique. \
            display_information2(
                utiltools.get_module_info(pms), u"Paramètres")
        actions[le2mtrans(u"Start")] = lambda _: self._demarrer()
        actions[le2mtrans(u"Display payoffs")] = \
            lambda _: self._le2mserv.gestionnaire_experience.\
            display_payoffs("Dictator")
        actions[le2mtrans(u"Show graph")] = self._show_fig
        self._le2mserv.gestionnaire_graphique.add_topartmenu(
            u"Dictator", actions)

    def _configure(self):
        """
        Pour configure la partie (traitement ...)
        :return:
        """
        pass

    @defer.inlineCallbacks
    def _demarrer(self):
        """
        Lancement de la partie. Définit tout le déroulement
        :return:
        """
        confirmation = self._le2mserv.gestionnaire_graphique.\
            question(u"Démarrer Dictator?")
        if not confirmation:
            return
        
        yield (self._le2mserv.gestionnaire_experience.init_part(
            "Dictator", "PartieDIC", "RemoteDIC", pms))
        
        # formation des groupes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if pms.TAILLE_GROUPES > 0:
            try:
                self._le2mserv.gestionnaire_groupes.former_groupes(
                    self._le2mserv.gestionnaire_joueurs.get_players(),
                    pms.TAILLE_GROUPES, forcer_nouveaux=True)
            except ValueError as e:
                self._le2mserv.gestionnaire_graphique.display_error(
                    e.message)
                return

        # in each group first player is A, the second is B
        for g, m in self._le2mserv.gestionnaire_groupes. \
                get_groupes("Dictator").iteritems():
            m[0].role = pms.PLAYER_A
            m[1].role = pms.PLAYER_B

        self._tous = self._le2mserv.gestionnaire_joueurs.get_players(
            'Dictator')
        self._playersA = [p for p in self._tous if
                          p.role == pms.PLAYER_A]
        self._le2mserv.gestionnaire_graphique.infoserv(
            _DIC("Players A"))
        self._le2mserv.gestionnaire_graphique.infoserv(
            map(str, [p.joueur for p in self._playersA]))

        # pour configure les clients et les remotes ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        yield (self._le2mserv.gestionnaire_experience.run_func(
            self._tous, "configure"))
    
        # START OF REPETITIONS =================================================
        for period in xrange(1 if pms.NOMBRE_PERIODES else 0,
                        pms.NOMBRE_PERIODES + 1):

            if self._le2mserv.gestionnaire_experience.stop_repetitions:
                break

            # initiate the period ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            self._le2mserv.gestionnaire_graphique.infoserv(
                [None, le2mtrans(u"Period {}").format(period)])
            self._le2mserv.gestionnaire_graphique.infoclt(
                [None, le2mtrans(u"Period {}").format(period)],
                fg="white", bg="gray")
            yield (self._le2mserv.gestionnaire_experience.run_func(
                self._tous, "newperiod", period))
            
            # decision ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            yield(self._le2mserv.gestionnaire_experience.run_step(
                le2mtrans(u"Decision"), self._playersA, "display_decision"))

            # store A decisions in B data
            for m in self._le2mserv.gestionnaire_groupes. \
            get_groupes("Dictator").itervalues():
                m[1].currentperiod.DIC_recu = m[0].currentperiod.DIC_decision
            
            # calcul des gains de la période ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            self._le2mserv.gestionnaire_experience.compute_periodpayoffs(
                "Dictator")
        
            # affichage du récapitulatif ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            yield(self._le2mserv.gestionnaire_experience.run_step(
                u"Summary", self._tous, "display_summary"))

        # Stats ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        data = pd.DataFrame(
            [p.currentperiod.todict(p.joueur) for p in self._playersA])
        data = data.groupby(data.joueur).mean()["DIC_decision"]
        self._fig, graph = plt.subplots(figsize=(6, 6))
        data.plot(kind="bar", ax=graph)
        # dec = np.array([
        #     p.currentperiod.DIC_decision for p in self._playersA])
        self._le2mserv.gestionnaire_graphique.infoserv(
            _DIC(u"Av. amount sent by players A\n{}").format(data.to_string()))
        # self._fig, graph = plt.subplots(figsize=(6, 6))
        # graph.bar(range(len(dec)), dec, width=0.2)
        # graph.set_xticks([i + 0.1 for i in range(len(dec))])
        # graph.set_xticklabels([u"j{}".format(i) for i in range(len(dec))])
        # graph.set_ylim(0, parametres.DOTATION)
        # graph.set_title(_DIC(u"Average amount sent by A players"))
        # graph.set_xlabel(_DIC(u"Players"))
        # graph.set_ylabel(_DIC(u"Amount sent"))

        # END OF PART ==========================================================
        self._le2mserv.gestionnaire_experience.finalize_part(
            "Dictator")

    def _show_fig(self):
        if not hasattr(self, "_fig"):
            return
        self._fig.show()